<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Story for Joe</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Great+Vibes&display=swap" rel="stylesheet">

    <!-- 
      This is an importmap. It's a modern, professional way 
      to import 3D libraries (like three.js) without any build tools.
      This is key to our "Â£1000" feel.
    -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js"
        }
      }
    </script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #0a0a1a; /* Very dark navy/black */
            color: #e5e7eb;
            font-family: 'Inter', sans-serif;
        }

        /* The 3D canvas is our background */
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* This container is invisible but creates the scrollbar. 
           600vh = 6 screens high, controlling the "length" of the journey. */
        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 600vh; 
            z-index: 3;
        }

        /* This container is fixed and holds all the HTML text overlays. */
        #content-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 2;
            /* We make it transparent to clicks so we can interact with the 3D scene if needed */
            pointer-events: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        /* Each text "scene" */
        .scene-text {
            position: absolute;
            max-width: 600px;
            padding: 2rem;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.7s ease-out, transform 0.7s ease-out;
            pointer-events: all; /* Text is clickable */
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* The .visible class is added by JavaScript */
        .scene-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Specific text styles */
        .scene-text h1 {
            font-size: 5rem;
            font-weight: 900;
            color: #fde047; /* Bright yellow */
        }
        
        .scene-text h2 {
            font-size: 4rem;
            font-weight: 700;
            color: #fff;
        }

        .scene-text p {
            font-size: 1.5rem;
            color: #d1d5db;
        }
        
        /* The final message */
        #scene-6 h2 {
            color: #4ade80; /* Green */
        }
        #scene-6 p {
            font-family: 'Great Vibes', cursive;
            font-size: 7rem;
            color: #fff;
        }
        
        /* A subtle loading indicator */
        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            font-size: 1.5rem;
            color: #fff;
        }

    </style>
</head>
<body>
    <!-- The 3D canvas -->
    <canvas id="bg"></canvas>
    
    <!-- The HTML text overlays -->
    <div id="content-container">
        <div id="loader">Loading 3D Experience...</div>
        
        <div id="scene-1" class="scene-text">
            <h1>To Joe...</h1>
            <p style="animation: bounce 2s infinite 1s; padding-top: 2rem;">(Scroll down to begin)</p>
        </div>
        
        <div id="scene-2" class="scene-text">
            <h2>Thanks for all the lifts.</h2>
            <p>Rain or shine, you've always been there.</p>
        </div>
        
        <div id="scene-3" class="scene-text">
            <h2>...and all the late-night BK closes.</h2>
            <p>Tou know your're the best shift manager right?.</p>
        </div>
        
        <div id="scene-4" class="scene-text">
            <h2>From BK to the Lake District.</h2>
            <p>Thanks for all the adventures and the good times on the hikes.</p>
        </div>

        <div id="scene-5" class="scene-text">
            <h2>Arriving home.</h2>
        </div>
        
        <div id="scene-6" class="scene-text">
            <h2>Merry Christmas, Joe!</h2>
            <p>From Jed ðŸŽ„</p>
        </div>
    </div>
    
    <!-- The invisible scrollbar creator -->
    <div id="scroll-container"></div>

    <!-- The 3D JavaScript "Engine" -->
    <script type="module">
        import * as THREE from 'three';
        // We have REMOVED FontLoader and TextGeometry, as they are the source of the problem.

        // --- GLOBAL VARS ---
        let scene, camera, renderer, car, road, stars;
        let ambientLight, dirLight, carLight;
        let loaderElement = document.getElementById('loader');
        
        // Arrays to hold objects for the journey
        const journeyObjects = new THREE.Group();
        // REMOVED textObjects
        const wheels = [];

        // Scroll progress (0.0 to 1.0)
        let scrollT = 0;
        let isDriving = false;

        // --- KEYPOSITIONS for the journey ---
        // We'll move the car from z=0 to z=-100
        const journeyLength = 100;
        const carStartPosition = new THREE.Vector3(0, 0.4, 0);
        const carEndPosition = new THREE.Vector3(0, 0.4, -journeyLength);
        
        const cameraFollowOffset = new THREE.Vector3(0, 3, 7);

        // --- INIT FUNCTION ---
        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50); // Cinematic fog

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10); // Start zoomed out
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;

            // Lights
            ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft ambient
            dirLight = new THREE.DirectionalLight(0xffffff, 3); // Main sun
            dirLight.position.set(10, 20, 5);
            dirLight.castShadow = true;
            
            // Car headlights
            carLight = new THREE.SpotLight(0xffffff, 5, 20, Math.PI * 0.1, 0.5);
            carLight.position.set(0, 1, -1); // Front of car
            carLight.target.position.set(0, 0, -10);

            scene.add(ambientLight, dirLight);

            // --- LOAD ASSETS & BUILD WORLD ---
            // We no longer need the try...catch or the font loader.
            
            // Create everything
            createCar();
            createRoad();
            createWorldObjects(); // Font parameter is removed
            createStars();
            
            scene.add(journeyObjects, stars); // Removed textObjects
            
            // Add car light to car group
            car.add(carLight, carLight.target);
            
            // Hide loader and show scene 1
            loaderElement.style.display = 'none';
            document.getElementById('scene-1').classList.add('visible');

            // Start the animation loop
            animate();
        }

        // --- CREATE 3D OBJECTS ---
        
        function createCar() {
            car = new THREE.Group();
            
            // Materials
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xef4444, roughness: 0.5 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1, metalness: 0.5 });
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(2, 0.8, 3.5);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            
            // Cabin
            const cabinGeo = new THREE.BoxGeometry(1.6, 0.7, 1.5);
            const cabin = new THREE.Mesh(cabinGeo, glassMat);
            cabin.position.set(0, 0.75, -0.2);
            
            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            wheelGeo.rotateZ(Math.PI / 2); // Orient them
            
            const wheelFL = new THREE.Mesh(wheelGeo, wheelMat);
            wheelFL.position.set(1.1, -0.1, 1);
            const wheelFR = new THREE.Mesh(wheelGeo, wheelMat);
            wheelFR.position.set(-1.1, -0.1, 1);
            const wheelRL = new THREE.Mesh(wheelGeo, wheelMat);
            wheelRL.position.set(1.1, -0.1, -1);
            const wheelRR = new THREE.Mesh(wheelGeo, wheelMat);
            wheelRR.position.set(-1.1, -0.1, -1);
            
            wheels.push(wheelFL, wheelFR, wheelRL, wheelRR);
            
            car.add(body, cabin, wheelFL, wheelFR, wheelRL, wheelRR);
            car.position.copy(carStartPosition);
            scene.add(car);
        }

        function createRoad() {
            // A long plane for the road
            const roadGeo = new THREE.PlaneGeometry(8, journeyLength + 20); // +20 for buffer
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x222228, roughness: 0.8 });
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -journeyLength / 2 + 10;
            road.receiveShadow = true;
            scene.add(road);
            
            // Dashed line
            const lineMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 0.5, gapSize: 0.5 });
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0.01, 10),
                new THREE.Vector3(0, 0.01, -journeyLength - 10)
            ]);
            const roadLine = new THREE.Line(lineGeo, lineMat);
            roadLine.computeLineDistances(); // Required for dashed lines
            scene.add(roadLine);
        }

        function createWorldObjects() { // Removed 'font' parameter
            // BK Sign (at z = -5)
            const bkSign = new THREE.Group();
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 2;
            
            const signGeo = new THREE.BoxGeometry(2, 1, 0.2);
            const signMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.y = 2.5;

            // REMOVED the 3D TextGeometry for "BK"

            // Create a glowing yellow "logo" block instead of text
            // This is our new, reliable "BK" sign
            const logoGeo = new THREE.BoxGeometry(1.5, 0.8, 0.1);
            const logoMat = new THREE.MeshBasicMaterial({ color: 0xfde047 }); // Basic material, will glow
            const logo = new THREE.Mesh(logoGeo, logoMat);
            logo.position.z = 0.11; // Slightly in front of sign
            
            // Add a light to make it "glow"
            const signLight = new THREE.PointLight(0xfde047, 5, 5);
            signLight.position.y = 0.5;
            
            sign.add(logo, signLight); // Added logo, removed text
            bkSign.add(pole, sign);
            bkSign.position.set(5, 0, -5);
            journeyObjects.add(bkSign);

            // Snacks (at z = -30)
            const snacks = new THREE.Group();
            const burgerMat = new THREE.MeshStandardMaterial({ color: 0x966919 });
            const bunGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
            const bunTop = new THREE.Mesh(bunGeo, burgerMat);
            bunTop.position.y = 0.3;
            const bunBottom = new THREE.Mesh(bunGeo, burgerMat);
            snacks.add(bunTop, bunBottom);
            
            const friesMat = new THREE.MeshStandardMaterial({ color: 0xfde047 });
            const fryGeo = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            for(let i=0; i<10; i++) {
                const fry = new THREE.Mesh(fryGeo, friesMat);
                fry.position.set(
                    THREE.MathUtils.randFloat(-0.2, 0.2),
                    THREE.MathUtils.randFloat(0, 0.25),
                    THREE.MathUtils.randFloat(-0.2, 0.2)
                );
                fry.position.y += 0.25;
                snacks.add(fry);
            }
            snacks.position.set(-5, 0.5, -30);
            journeyObjects.add(snacks);

            // Mountains (at z = -60)
            const mountainGeo = new THREE.ConeGeometry(8, 15, 6);
            const mountainMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 1 });
            const m1 = new THREE.Mesh(mountainGeo, mountainMat);
            m1.position.set(-10, 7.5, -60);
            const m2 = new THREE.Mesh(mountainGeo, mountainMat);
            m2.scale.set(0.8, 0.8, 0.8);
            m2.position.set(12, 6, -65);
            journeyObjects.add(m1, m2);
            
            // Home (at z = -100)
            const home = new THREE.Group();
            const houseGeo = new THREE.BoxGeometry(2, 2, 2);
            const houseMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const house = new THREE.Mesh(houseGeo, houseMat);
            house.position.y = 1;
            
            const roofGeo = new THREE.ConeGeometry(1.7, 1, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x800000 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 2.5;
            roof.rotation.y = Math.PI / 4;
            
            home.add(house, roof);
            home.position.set(0, 0, -journeyLength);
            journeyObjects.add(home);
        }

        // DELETED the entire 'createFloatingText' function

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            const starVertices = [];
            for(let i=0; i<10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                starVertices.push(x, y, z);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeo, starMat);
            stars.position.z = -100; // Place them far back
        }


        // --- ANIMATION & SCROLL ---

        function onScroll() {
            // Calculate scroll percentage
            const scrollTop = document.documentElement.scrollTop;
            const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            scrollT = scrollTop / docHeight;
            
            // Check if driving
            isDriving = scrollT > 0.01 && scrollT < 0.9;

            // --- Update HTML Text Scenes ---
            const scenes = document.querySelectorAll('.scene-text');
            scenes.forEach(s => s.classList.remove('visible'));
            
            if (scrollT < 0.08) document.getElementById('scene-1').classList.add('visible');
            else if (scrollT < 0.25) document.getElementById('scene-2').classList.add('visible');
            else if (scrollT < 0.45) document.getElementById('scene-3').classList.add('visible');
            else if (scrollT < 0.65) document.getElementById('scene-4').classList.add('visible');
            else if (scrollT < 0.85) document.getElementById('scene-5').classList.add('visible');
            else document.getElementById('scene-6').classList.add('visible');
        }
        window.addEventListener('scroll', onScroll, { passive: true });
        onScroll(); // Call once on load

        // The animation loop
        function animate() {
            requestAnimationFrame(animate);

            // --- SMOOTH LERPING ---
            // This is the "Apple" magic. We smoothly "lerp" (linear interpolate) 
            // the 3D objects to their target positions based on scroll.
            
            // 1. Car Position
            // The car's target z is lerped from start to end based on scrollT
            const carTargetZ = THREE.MathUtils.lerp(carStartPosition.z, carEndPosition.z, scrollT);
            car.position.z = THREE.MathUtils.lerp(car.position.z, carTargetZ, 0.05);

            // 2. Camera Position
            let cameraTarget = new THREE.Vector3();
            if (scrollT < 0.9) {
                // Camera follows car
                cameraTarget.copy(car.position).add(cameraFollowOffset);
            } else {
                // Finale: Camera detaches and pans up
                cameraTarget.copy(car.position).add(new THREE.Vector3(0, 10, -5));
            }
            
            // Smoothly move camera to its target
            camera.position.lerp(cameraTarget, 0.05);
            // Always look at the car
            camera.lookAt(car.position);
            
            // 3. Wheel Spinning
            if (isDriving) {
                wheels.forEach(w => w.rotation.x -= 0.2);
            }
            
            // DELETED the "Floating Text" billboarding logic

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        // --- START ---
        init();

    </script>
</body>
</html>